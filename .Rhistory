library(tidyverse)
library(readr)
library(forcats)
library(effsize)
library(rcompanion)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
source("ProductionData_randsubj.R")
library(ggplot2)
library(tidyverse)
library(readr)
library(forcats)
library(effsize)
library(rcompanion)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
source("ProductionData_randsubj.R")
library(tidyverse)
library(forcats)
CPdata <- read_csv("Data/CPdata_randsubj.csv") %>%# read in CPdata_randsubj.csv to use as a base df for all following dfs
mutate(subj = factor(subj))
ProdData <- CPdata %>%
group_by(subj, month, sex, MOTedu, VMSgroup, VMS) %>%
tally() %>%
ungroup() %>%
rename("CPtokens" = "n") %>%
mutate(MOTedulevel = fct_recode(MOTedu,
"1" = "High School",
"2" =  "Some college",
"3" = "Assoc Degree",
"4" = "Bachelors Degree",
"5" = "Masters Degree",
"6" =  "Doctorate"))
ProdData$MOTedulevel <- as.numeric(as.character(ProdData$MOTedulevel))
CPtyp <- CPdata %>%
group_by(subj) %>%
summarise(CPtypes = n_distinct(ctype)) %>%  # How many CP types produced per infant?
ungroup()
VMS.Prod <- CPdata %>%
group_by(subj, VMS.Prod.Cong, VMSgroup) %>%
tally() %>%
spread(VMS.Prod.Cong, n) %>%
rename(VMS.Prod.NoMatch = `FALSE`,
VMS.Prod.Match = `TRUE`) %>%
mutate(VMS.Prod.Match = ifelse(VMSgroup!="noVMS" & is.na(VMS.Prod.Match),0,VMS.Prod.Match),  # Variable only applies to withVMS infants
VMS.Prod.NoMatch = ifelse(VMSgroup!="noVMS" & is.na(VMS.Prod.NoMatch),0,VMS.Prod.NoMatch), # Keep noVMS infants as NA, change withVMS infants with no CPs to 0
VMS.Prod.match.PC = VMS.Prod.Match/(VMS.Prod.Match+VMS.Prod.NoMatch)) # For infants who have VMS, what % of CPs are congruent with VMS?
Prod.Obj <- CPdata %>%                  # Only includes 43 infants as subj 944 doesn't have any attended objects
filter(!grepl("^\\[",object)) %>%    # exclude all instances where object is coded as [toy], [unclear], etc but keep insances of e.g. 'lxx [name]'
group_by(subj, Prod.Obj.Cong, VMSgroup) %>%
tally() %>%
spread(Prod.Obj.Cong, n) %>%
ungroup() %>%
replace(is.na(.), 0) %>%               # analysis includes all infants, so change all NAs to 0 across VMS groups
rename(Prod.Obj.NoMatch = `FALSE`,
Prod.Obj.Match = `TRUE`) %>%
mutate(Prod.Obj.match.PC = Prod.Obj.Match/(Prod.Obj.Match+Prod.Obj.NoMatch)) # What % of attended objects match infants' CPs?
Prod.Prompt <- CPdata %>%
filter(!grepl("^\\[",cgprompt)) %>%     # exclude all instances where object is coded as [toy], [unclear], etc but keep insances of e.g. 'lxx [name]'
group_by(subj, Prod.Prompt.Cong, VMSgroup) %>%
tally() %>%
spread(Prod.Prompt.Cong, n) %>%
replace(is.na(.), 0) %>%               # analysis includes all infants, so change all NAs to 0 across VMS groups
rename(Prod.Prompt.NoMatch = `FALSE`,
Prod.Prompt.Match = `TRUE`) %>%
mutate(Prod.Prompt.match.PC = Prod.Prompt.Match/(Prod.Prompt.Match+Prod.Prompt.NoMatch)) # What % of CG prompts match infants' CPs?
CP.Obj <- CPdata %>%
filter(!grepl("^\\[",object)) %>%    # exclude all instances where object is coded as [toy], [unclear], etc
group_by(subj) %>%
count() %>%
rename(nObj = n) %>% # How many CPs are accompanied by an Object?
ungroup() %>%
add_row(subj = "944", nObj = 0)   # subj 944 has no objects, so add this row manually
CP.Prompt <- CPdata %>%
filter(!grepl("^\\[",cgprompt)) %>%  # exclude all instances where prompt is coded as [unclear], etc, but include eg. "txx [chi name]"
group_by(subj) %>%
tally() %>%
rename(nPrompt = n)    # How many CPs are accompanied by a CG Prompt?
cong.CP.P <- CPdata %>%
filter(VMS.Prompt.Cong == T) %>%   # withVMS infants only; one infant has no VMS congruent prompts
group_by(subj, Prod.Prompt.Cong, VMSgroup) %>%
tally() %>%
spread(Prod.Prompt.Cong, n) %>%
ungroup() %>%
replace(is.na(.), 0) %>%    # Change NAs in the No.cong.CP.P column to 0 so %s can be calculated for all withVMS infants
rename(cong.CP.P = `TRUE`,
No.cong.CP.P = `FALSE`) %>%
mutate(PCVMSMatch.Prompt = cong.CP.P/(cong.CP.P+No.cong.CP.P))  # When there is a VMS-congruent CG prompt, how often do infants respond with a congruent CP?
cong.CP.O <- CPdata %>%
filter(VMS.Obj.Cong == T) %>%    # withVMS infants only; two infants have no VMS congruent objects
group_by(subj, Prod.Obj.Cong, VMSgroup) %>%
tally() %>%
spread(Prod.Obj.Cong, n) %>%
ungroup() %>%
replace(is.na(.), 0) %>%      # Change NAs in the No.cong.CP.O column to 0 so %s can be calculated for all withVMS infants
rename(cong.CP.O = `TRUE`,
No.cong.CP.O = `FALSE`) %>%
mutate(PCVMSMatch.Obj = cong.CP.O/(cong.CP.O+No.cong.CP.O)) #  When there is a VMS-congruent Object, how often do infants respond with a congruent CP?
incong.CP.P <- CPdata %>%
filter(VMS.Prompt.Cong == F,            # includes withVMS and noVMS infants (noVMS infants all filter as VMS.Prompt.Cong ==F)
!grepl("^\\[",cgprompt)) %>%     # filter out all instances of [unclear], etc but keep, e.g. 'lxx [name]'
group_by(subj, Prod.Prompt.Cong) %>%
tally() %>%
spread(Prod.Prompt.Cong, n) %>%
replace(is.na(.), 0) %>%           # Change NAs to 0 so %s can be calculated for all infants
rename(incong.CP.P = `TRUE`,
No.incong.CP.P = `FALSE`) %>%
mutate(PCNoVMSMatch.Prompt = incong.CP.P/(incong.CP.P+No.incong.CP.P)) # When there is a VMS-INcongruent CG prompt, how often do infants respond with a congruent CP?
incong.CP.O <- CPdata %>%
filter(VMS.Obj.Cong == F,             # includes withVMS and noVMS infants (noVMS infants all filter as VMS.Obj.Cong ==F )
!grepl("^\\[",object)) %>%     # filter out all instances of [toy], [unavailable], etc but keep, e.g. 'lxx [name]'
group_by(subj, Prod.Obj.Cong) %>%
tally() %>%
spread(Prod.Obj.Cong, n) %>%
ungroup() %>%
replace(is.na(.), 0) %>%                           # Change NAs to 0 so %s can be calculated for all infants
rename(incong.CP.O = `TRUE`,
No.incong.CP.O = `FALSE`) %>%
mutate(PCNoVMSMatch.Obj = incong.CP.O/(incong.CP.O+No.incong.CP.O))  # When there is a VMS-INcongruent Object, how often do infants respond with a congruent CP?
getwd()
# Updated 16th April 2019
# This script takes CPdata and scrambles various aspects of infant and caregiver data. It then recreates the TRUE/FALSE binomials in line with
# these randomly scarmbled responses, and re-calculates all proportions based on these.
library(tidyverse)
CPdata <- read_csv("Data/CPdata_randsubj.csv") %>%# read in CPdata_randsubj.csv to use as a base df for all following dfs
mutate(subj = factor(subj))
set.seed(42) #meaning of life
CPdata.scr.C1Prompt <- dplyr::select(CPdata, subj, month, sex, VMSgroup, ctype, VMS, C1Obj, C1Prompt) %>%
mutate(Prompt.scrambled = sample(C1Prompt)) # C1 of CG prompts are scrambled
set.seed(13) #lucky number
CPdata.scr.C1Prompt.C1Obj <- CPdata.scr.C1Prompt %>%
mutate(Object.scrambled = sample(C1Obj))# C1 of attended objects are scrambled
set.seed(1) #loneliest number
CPdata.scr.C1Prompt.C1Obj.ctype <- CPdata.scr.C1Prompt.C1Obj %>%
mutate(InfantProd.scrambled = sample(ctype)) # Infants' CPs are scrambled
CPdata.scr <- CPdata.scr.C1Prompt.C1Obj.ctype %>%
mutate(Prompt.inProd = stri_detect_regex(as.character(ctype), as.character(Prompt.scrambled)), # is scrambled prompt congruent with CP
Object.inProd = stri_detect_regex(as.character(ctype), as.character(Object.scrambled)), # is scrambled object congruent with CP
VMS.match = stri_detect_regex(VMS, as.character(InfantProd.scrambled)) # Does VMS match scrambled CP
)
library(ggplot2)
library(readr)
library(forcats)
library(effsize)
library(rcompanion)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
source("ProductionData_randsubj.R")
install.packages("stringi")
install.packages("stringi")
install.packages("stringi")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(readr)
library(forcats)
library(effsize)
library(rcompanion)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
source("ProductionData_randsubj.R")
library(stringi)
install.packages("stringi")
library(stringi)
library(stringi)
library(stringr)
library(stringi)
library(tidyverse)
#library(stringr)
library(stringi)
library(tidyverse)
#library(stringr)
library(stringi)
libPaths()
.libPaths()
loadedNamespaces()
install.packages("stringi")
library(tidyverse)
#library(stringr)
library(stringi)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(readr)
library(forcats)
library(effsize)
library(rcompanion)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
source("ProductionData_randsubj.R")
source("Data_scrambling_randsubj.R")
vmstotal %>% filter(VMSgroup == "withVMS") %>% group_by(sex) %>% tally() #24
vmscount %>% filter(Group == "Multi") %>% group_by(subj, VMS, sex) %>% tally() #11
vmscount %>% filter(Group == "One") %>% group_by(subj, VMS, sex) %>% tally() #13
vmstotal %>% filter(VMSgroup == "noVMS") %>% group_by(sex) %>% tally() #20 (8)
vmstotal %>% filter(VMS == "p b") %>% group_by(sex) %>% tally() # 8 (6)
vmstotal %>% filter(VMS == "t d") %>% group_by(sex) %>% tally() # 4 (1)
vmstotal %>% filter(VMS == "k g") %>% group_by(sex) %>% tally() # 1 (0)
vmstotal %>% filter(VMS == "p b m") %>% group_by(sex) %>% tally() # 1 (0)
vmstotal %>% filter(VMS == "p b t d") %>% group_by(sex) %>% tally() # 1 (1)
vmstotal %>% filter(VMS == "p b k g") %>% group_by(sex) %>% tally() # 4(2)
vmstotal %>% filter(VMS == "t d k g") %>% group_by(sex) %>% tally() # 2(1)
vmstotal %>% filter(VMS == "t d n") %>% group_by(sex) %>% tally() # 1(1)
vmstotal %>% filter(VMS == "p b t d n") %>% group_by(sex) %>% tally() # 1(0)
vmstotal %>% filter(VMS == "p b t d k g") %>% group_by(sex) %>% tally() # 1 (1)
vmstotal %>% filter(VMS == "p b t d k g") %>% group_by(sex) %>% tally() # 1 (1)
vmstotal %>% group_by(month) %>% tally()
vmstotal %>% group_by(VMSgroup) %>% filter(month == 10) %>% tally()
CPdata %>% tally() # 1916 CPs
CPdata %>% filter(cgprompt != "[none]" &
cgprompt != "[unclear]" &
cgprompt != "[unavailable]" &
cgprompt != "[imitation]" &
cgprompt != "[media]") %>%
tally() # 976
976/1916 # 51%
CPdata %>% filter(wordclass != "[none]") %>% tally() # 976
CPdata %>% filter(object != "[none]" & object != "[unclear]" & object != "[out of view]") %>% tally() # 1179
1179/1916 # 62%
CPdata %>% filter(object == "[toy]") %>% tally() # 78
1179-78
CPdata %>% filter(!grepl("^\\[",cgprompt) & C1Prompt == "none") %>% tally()  # 40 instances of CGprompts with no supraglottal consonant
CPdata %>% filter(!grepl("^\\[", object) & C1Obj == "none") %>% tally()  # 58 instances of Objects with no supraglottal consonant
wilcox.test(audiotokens ~ month, vmstotal) # ns p=.718
wilcox.test(audiotokens ~ sex, vmstotal) # ns p=.541
ProdData %>% mutate(outlier = (CPtokens >
(mean(CPtokens, na.rm=T) +
3*(sd(CPtokens, na.rm=T))) |
CPtokens <
(mean(CPtokens, na.rm=T) -
3*(sd(CPtokens, na.rm=T))))) %>%
filter(outlier == TRUE)  # no outliers
ProdData %>% mutate(outlier = (CPtypes >
(mean(CPtypes, na.rm=T) +
3*(sd(CPtypes, na.rm=T))) |
CPtypes <
(mean(CPtypes, na.rm=T) -
3*(sd(CPtypes, na.rm=T))))) %>%
filter(outlier == TRUE)  # no outliers
vmscount %>% group_by(subj) %>% summarise(total = sum(n)) %>% ungroup() %>% summarise(meanprod = mean(total), #96.59
sdprod = sd(total),  #116.64
minprod = min(total), #0
maxprod = max(total)) #610
vmscount %>% group_by(subj) %>% summarise(total = sum(n)) %>% filter(total == 0) %>% tally() #3 infant with 0 productions
vmscount %>% group_by(Consonant) %>% summarise(total = sum(n))
Figure1a <- ggplot(subset(vmscount, VMSgroup == "withVMS"), aes(x=Consonant, y=log10(n))) +
stat_summary(fun.y=mean, geom = "point", aes(group = subj, colour = Consonant), shape=1, size=2,
position = position_jitter(width = .1, height=0)) +
stat_summary(fun.data=mean_cl_boot, geom = "pointrange", shape=2, size=1) +
scale_x_discrete(limits = c("p", "t", "k", "m", "n"),
labels = c("pb", "td", "kg", "m", "n")) +
theme_bw(base_size=15) +
scale_y_continuous(breaks=c(0, .301, 1, 1.699, 2.69897), labels=c(0, 2, 10, 50, 500)) +
xlab("Consonant Type") +
ylab("n") +
theme(legend.position = "none",
axis.title = element_text(size=22),
axis.text = element_text(size=22),
strip.text = element_text(face="bold", size=22,lineheight=7.0)) +
facet_wrap(~VMSgroup)
Figure1b <- ggplot(subset(vmscount, VMSgroup == "noVMS"), aes(x=Consonant, y=log10(n))) +
stat_summary(fun.y=mean, geom = "point", aes(group = subj, colour = Consonant), shape=1, size=2,
position = position_jitter(width = .1, height=0)) +
stat_summary(fun.data=mean_cl_boot, geom = "pointrange", shape=2, size=1) +
scale_x_discrete(limits = c("p", "t", "k", "m", "n"),
labels = c("pb", "td", "kg", "m", "n")) +
theme_bw(base_size=15) +
scale_y_continuous(breaks=c(0, .301, 1, 1.477, 1.699, 2), labels=c(0, 2, 10, 30, 50, 100)) +
xlab("Consonant Type") +
ylab("n") +
theme(legend.position = "none",
axis.title = element_text(size=22),
axis.text = element_text(size=22),
strip.text = element_text(face="bold", size=22,lineheight=7.0)) +
facet_wrap(~VMSgroup)
multiplot(Figure1a, Figure1b, cols=2)
CPdata %>% filter(cgresponse == "None" | is.na(cgresponse)) %>% tally() #1404
source("ProductionData_nostimmatch_randsubj.R")
source("ProductionData_nostimmatch_randsubj.R")
source("Data_scrambling_nostimmatch_randsubj.R")
library(effsize)
1916-1772 # Total CPs in original data - total CPs in data with matches removed = 144
144/1916 #.08 of all CPs from original analysis
ProdData_nostimmatch %>% ungroup() %>% summarise(totalprompt = sum(nPrompt)) # 839
wilcox.test(subset(ProdData_nostimmatch, VMSgroup == "withVMS")$Prod.Prompt.match.PC,
subset(ProdData_nostimmatch, VMSgroup == "noVMS")$Prod.Prompt.match.PC, conf.int = T) # Significant, p<.001
cliff.delta(d = subset(ProdData_nostimmatch, VMSgroup == "withVMS")$Prod.Prompt.match.PC,
f = subset(ProdData_nostimmatch, VMSgroup == "noVMS")$Prod.Prompt.match.PC) # .34, medium
prompt.real <- ProdData_nostimmatch %>%
select(subj, month, VMSgroup, Prod.Prompt.match.PC) %>%
ungroup() %>%
rename(PC = Prod.Prompt.match.PC) %>%
mutate(Type = 'real')
prompt.scramble <- data.scrambled_nostimmatch %>%
ungroup() %>%
select(subj, month, VMSgroup, Prod.Prompt.match.PC) %>%
rename(PC = Prod.Prompt.match.PC) %>%
mutate(Type = 'scrambled')
scramble.comparison.prompt <- rbind(prompt.real, prompt.scramble)
wilcox.test(subset(prompt.real, VMSgroup == "withVMS")$PC,
subset(prompt.scramble, VMSgroup == "withVMS")$PC, conf.int = T) # Significant, p<.001
# How many CPs match C1 of both prompt and object?
CPdata %>%
mutate(match = str_detect(C1Obj, fixed(C1Prompt)),  # Is there a consonantal match: T/F
match = ifelse(C1Obj == "none" & C1Prompt == "n", F, match),
# ^ none matches n in above line, so make sure these are included here
match = ifelse(C1Prompt == "none" & C1Obj == "n", F, match)) %>% # and vice versa
filter(match == TRUE & C1Obj != "none") %>% tally() # 223    # exclude all matches of 'none'
223/1916 # 12% of original dataset
source("ProductionData_noC1match.R")
CPdata %>%
mutate(match = str_detect(C1Obj, fixed(C1Prompt)),  # Is there a consonantal match: T/F
match = ifelse(C1Obj == "none" & C1Prompt == "n", F, match),
# ^ none matches n in above line, so make sure these are included here
match = ifelse(C1Prompt == "none" & C1Obj == "n", F, match)) %>% # and vice versa
filter(match == TRUE & C1Obj != "none") %>% tally() # 223    # exclude all matches of 'none'
# How many CPs match C1 of both prompt and object?
CPdata %>%
mutate(match = str_detect(C1Obj, fixed(C1Prompt)),  # Is there a consonantal match: T/F
match = ifelse(C1Obj == "none" & C1Prompt == "n", F, match),
# ^ none matches n in above line, so make sure these are included here
match = ifelse(C1Prompt == "none" & C1Obj == "n", F, match)) %>% # and vice versa
filter(match == TRUE & C1Obj != "none") %>% tally() # 223    # exclude all matches of 'none'
223/1916 # 12% of original dataset
source("ProductionData_noC1match_randsubj.R")
source("Data_scrambling_noC1match_randsubj.R")
1916-1693 # 223   # check that numbers are correct in new CP data
source("Data_scrambling_Nounsonly.R")
source("Data_scrambling_Nounsonly_nostimmatch.R")
source("Data_scrambling_Nounsonly_randsubj.R")
install.packages("rcompanion")
??stri_detect_regex
qplot(rnorm(100))
qqplot(rnorm(100))
hist(rnorm(100))
hist(rnorm(1000))
ggplot(aes(rnorm(1000)))+geom_density()
library(ggplot2)
ggplot(aes(rnorm(1000)))+geom_density()
rnorm1000 <- rnorm(10000)
ggplot(aes(rnorm1000))+geom_density()
rnorm10000
rnorm1000
qplot(aes(rnorm1000))+geom_density()
rnorm1000 <- rnorm(10000) %>% as.tibble()
library(tidyverse)
rnorm1000 <- rnorm(10000) %>% as.tibble()
rnorm1000 <- rnorm(10000) %>% as_tibble()
rnorm1000
ggplot(data=rnorm1000,aes(value))+geom_density()
ggplot(data=rnorm1000,aes(value))+geom_density()+geom_point(value()
)
ggplot(data=rnorm1000,aes(value))+geom_density()+geom_point()
rnorm1000$value2 <- value+1
rnorm1000$value2 <- rnorm1000$value+1
ggplot(data=rnorm1000,aes(value))+geom_density()+geom_density(aes(value2))
rnorm1000$value3 <- rnorm1000$value+5
ggplot(data=rnorm1000,aes(value))+geom_density()+geom_density(aes(value2))+geom_density(aes(value3))
ggplot(data=rnorm1000,aes(value, color = "taupe"))+geom_density()+geom_density(aes(value2, color = "green"))+geom_density(aes(value3, color = "blue"))
ggplot(data=rnorm1000,aes(value, color = taupe))+geom_density()+geom_density(aes(value2, color = "green"))+geom_density(aes(value3, color = "blue"))
ggplot(data=rnorm1000,aes(value, color = "taupe"))+geom_density()+geom_density(aes(value2, color = "green"))+geom_density(aes(value3, color = "blue"))
ggplot(data=rnorm1000,aes(value, color = "blue"))+geom_density()+geom_density(aes(value2, color = "green"))+geom_density(aes(value3, color = "red"))
ggplot(data=rnorm1000,aes(value, color = "red"))+geom_density()+geom_density(aes(value2, color = "green"))+geom_density(aes(value3, color = "blue"))
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2, color = "green"))+geom_density(aes(value3, color = "blue"))
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2), color = "green")+geom_density(aes(value3), color = "blue")
taupe
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2), color = "taupe")+geom_density(aes(value3), color = "blue")
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2), color = "black")+geom_density(aes(value3), color = "blue")
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2), color = "black")+geom_density(aes(value3), color = "blue")+xlab("Feature X")
rnorm1000$value4 <- rnorm(1000,sd = 3)
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2), color = "black")+geom_density(aes(value3), color = "blue")+xlab("Feature X")+geom_density(aes(value4), color="orange")
rnorm1000$value4 <- rnorm(10000,sd = 3)
ggplot(data=rnorm1000,aes(value))+geom_density(color = "red")+geom_density(aes(value2), color = "black")+geom_density(aes(value3), color = "blue")+xlab("Feature X")+geom_density(aes(value4), color="orange")
install.packages("stringi")
library(stringi)
??stri_detect_regex
library(stringi)
library(stringr)
library(stringi)
library("stringi", lib.loc="~/Library/R/3.5/library")
install.packages("stringi")
library(stringi)
?wilcoxonPairedR
??wilcoxonPairedR
